<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.31.1" />
  <meta name="author" content="董雷鸣Leiming Dong">
  <meta name="description" content="PhD">

  
  <link rel="alternate" hreflang="en-us" href="../../post/2018-01-20-ericjang/">

  
  


  

  
  
  
  
    
  
  
    
    
      
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
      
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="../../styles.css">
  

  

  
  <link rel="alternate" href="../../index.xml" type="application/rss+xml" title="Enterprising &amp; Concentrating">
  <link rel="feed" href="../../index.xml" type="application/rss+xml" title="Enterprising &amp; Concentrating">
  

  <link rel="manifest" href="../../site.webmanifest">
  <link rel="icon" type="image/png" href="../../img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="../../img/icon-192.png">

  <link rel="canonical" href="../../post/2018-01-20-ericjang/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@donglm2008">
  <meta property="twitter:creator" content="@donglm2008">
  
  <meta property="og:site_name" content="Enterprising &amp; Concentrating">
  <meta property="og:url" content="/post/2018-01-20-ericjang/">
  <meta property="og:title" content="2018-01-20-ericjang | Enterprising &amp; Concentrating">
  <meta property="og:description" content="">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2018-01-20T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2018-01-20T00:00:00&#43;00:00">
  

  

  <title>2018-01-20-ericjang | Enterprising &amp; Concentrating</title>

</head>
<body id="top" data-spy="scroll" data-target="#toc" data-offset="71" >

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="../../"><img src="../../img/dong_logo.png" alt="Enterprising &amp; Concentrating"></a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      
      <ul class="nav navbar-nav navbar-right">
        

        

        
          
        

        <li class="nav-item">
          <a href="../../#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="../../#posts">
            
            <span>Posts</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="../../#publications">
            
            <span>Publications</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="../../#projects">
            
            <span>Projects</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="../../#contact">
            
            <span>Contact</span>
            
          </a>
        </li>

        
        
      

      
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <div class="article-inner">
      <h1 itemprop="name">2018-01-20-ericjang</h1>

      

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2018-01-20 00:00:00 &#43;0000 UTC" itemprop="datePublished dateModified">
      Jan 20, 2018
    </time>
  </span>
  <span itemscope itemprop="author publisher" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="董雷鸣Leiming Dong">
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    15 min read
  </span>
  

  
  
  <span class="middot-divider"></span>
  <a href="../../post/2018-01-20-ericjang/#disqus_thread"></a>
  

  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=2018-01-20-ericjang&amp;url=%2fpost%2f2018-01-20-ericjang%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2f2018-01-20-ericjang%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2f2018-01-20-ericjang%2f&amp;title=2018-01-20-ericjang"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2f2018-01-20-ericjang%2f&amp;title=2018-01-20-ericjang"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=2018-01-20-ericjang&amp;body=%2fpost%2f2018-01-20-ericjang%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>


      <div class="article-style" itemprop="articleBody">
        <p>Eric Jang</p>
<p>Technology, A.I., Careers</p>
<p>Wednesday, January 17, 2018 <a href="http://blog.evjang.com/2018/01/nf1.html"></a> Normalizing Flows Tutorial, Part 1: Distributions and Determinants# E If you are a machine learning practitioner working on generative modeling, Bayesian deep learning, or deep reinforcement learning, normalizing flows are a handy technique to have in your algorithmic toolkit. Normalizing flows transform simple densities (like Gaussians) into rich complex distributions that can be used for generative models, RL, and variational inference. TensorFlow has a nice set of functions that make it easy to build flows and train them to suit real-world data.</p>
<p>This tutorial comes in two parts: Part 1: Distributions and Determinants. In this post, I explain how invertible transformations of densities can be used to implement more complex densities, and how these transformations can be chained together to form a “normalizing flow”. Part 2: Modern Normalizing Flows: In a follow-up post, I survey recent techniques developed by researchers to learn normalizing flows, and explain how a slew of modern generative modeling techniques – autoregressive models, MAF, IAF, NICE, Real-NVP, Parallel-Wavenet – are all related to each other. This series is written for an audience with a rudimentary understanding of linear algebra, probability, neural networks, and TensorFlow. Knowledge of recent advances in Deep Learning, generative models will be helpful in understanding the motivations and context underlying these techniques, but they are not necessary.</p>
<p>Background</p>
<p>Statistical Machine Learning algorithms try to learn the structure of data by fitting a parametric distribution <span class="math inline">\(p(x; \theta)\)</span> to it. Given a dataset, if we can represent it with a distribution, we can: Generate new data “for free” by sampling from the learned distribution in silico; no need to run the true generative process for the data. This is a useful tool if the data is expensive to generate, i.e. a real-world experiment that takes a long time to run [1]. Sampling is also used to construct estimators of high-dimensional integrals over spaces. Evaluate the likelihood of data observed at test time (this can be used for rejection sampling or to score how good our model is). Find the conditional relationship between variables. For example, learning the distribution <span class="math inline">\(p(x_2 | x_1)\)</span> allows us to build discriminative classification or regression models. Score our algorithm by using complexity measures like entropy, mutual information, and moments of the distribution. We’ve gotten pretty good at sampling (1), as evidenced by recent work on generative models for images and audio. These kinds of generative models are already being deployed in real commercial applications and Google products.</p>
<p>However, the research community currently directs less attention towards unconditional &amp; conditional likelihood estimation (2, 3) and model scoring (4). For instance, we don’t know how to compute the support of a GAN decoder (how much of the output space has been assigned nonzero probability by the model), we don’t know how to compute the density of an image with respect to a DRAW distribution or even a VAE, and we don’t know how to analytically compute various metrics (KL, earth-mover distance) on arbitrary distributions, even if we know their analytic densities.</p>
<p>Generating likely samples isn’t enough: we also care about answering “how likely is the data?” [2], having flexible conditional densities (e.g. for sampling/evaluating divergences of multi-modal policies in RL), and being able to choose rich families of priors and posteriors in variational inference.</p>
<p>Consider for a moment, your friendly neighborhood Normal Distribution. It’s the Chicken Soup of distributions: we can draw samples from it easily, we know its analytic density and KL divergence to other Normal distributions, the central limit theorem gives us confidence that we can apply it to pretty much any data, and we can even backprop through its samples via the reparameterization trick. The Normal Distribution’s ease-of-use makes it a very popular choice for many generative modeling and reinforcement learning algorithms.</p>
<p>Unfortunately, the Normal distribution just doesn’t cut it in many real-world problems we care about. In Reinforcement Learning – especially continuous control tasks such as robotics – policies are often modeled as multivariate Gaussians with diagonal covariance matrices.</p>
<p>By construction, uni-modal Gaussians cannot do well on tasks that require sampling from a multi-modal distribution. A classic example of where uni-modal policies fail is an agent trying to get to its house across a lake. It can get home by circumventing the lake clockwise (left) or counterclockwise (right), but a Gaussian policy is not able to represent two modes. Instead, it chooses actions from a Gaussian whose mean is a linear combination of the two modes, resulting in the agent going straight into the icy water. Sad!</p>
<p>The above example illustrates how the Normal distribution can be overly simplistic. In addition to bad symmetry assumptions, Gaussians have most of their density concentrated at the edges in high dimensions and are not robust to rare events. Can we find a better distribution with the following properties?</p>
<p>Complex enough to model rich, multi-modal data distributions like images and value functions in RL environments? … while retaining the easy comforts of a Normal distribution: sampling, density evaluation, and with re-parameterizable samples? The answer is yes! Here are a few ways to do it: Use a mixture model to represent a multi-modal policy, where a categorical represents the “option” and the mixture represents the sub-policy. This provides samples that are easy to sample and evaluate, but samples are not trivially re-parameterizable, which makes them hard to use for VAEs and posterior inference. However, using a Gumbel-Softmax / Concrete relaxation of the categorical “option” would provide a multi-modal, re-parameterizable distribution. Autoregressive factorizations of policy / value distributions. In particular, discrete distributions (e.g. Categorical) have the ability to model arbitrary discrete distributions. In RL, one can avoid this altogether by symmetry-breaking the value distribution via recurrent policies, noise, or distributional RL. This helps by collapsing the complex value distributions into simpler conditional distributions at each timestep. Learning with energy-based models, a.k.a undirected graphical models with potential functions that eschew an normalized probabilistic interpretation. Here’s a recent example of this applied to RL. Normalizing Flows: learn invertible, volume-tracking transformations of distributions that we can manipulate easily.</p>
<p>Let’s explore the last approach - Normalizing Flows.</p>
<p>Change of Variables, Change of Volume</p>
<p>Let’s build up some intuition by examining linear transformations of 1D random variables. Let <span class="math inline">\(X\)</span> be the distribution <span class="math inline">\(\text{Uniform}(0,1)\)</span>. Let random variable <span class="math inline">\(Y = f(X) = 2X + 1\)</span>. <span class="math inline">\(Y\)</span> is a simple affine (scale &amp; shift) transformation of the underlying “source distribution” <span class="math inline">\(X\)</span>. What this means is that a sample <span class="math inline">\(x^i\)</span> from <span class="math inline">\(X\)</span> can be converted into a sample from <span class="math inline">\(Y\)</span> by simply applying the function <span class="math inline">\(f\)</span> to it.</p>
<p>The green square represents the shaded probability mass on <span class="math inline">\(\mathbb{R}\)</span> for both <span class="math inline">\(p(x)\)</span> and <span class="math inline">\(p(y)\)</span> - the height represents the density function at that value. Observe that because probability mass must integrate to 1 for any distribution, the act of scaling the domain by 2 everywhere means we must divide the probability density by 2 everywhere, so that the total area of the green square and blue rectangle are the same (=1).</p>
<p>If we zoom in on a particular x and an infinitesimally nearby point <span class="math inline">\(x+dx\)</span>, then applying f to them takes us to the pair <span class="math inline">\((y, y+dy)\)</span>.</p>
<p>On the left, we have a locally increasing function (<span class="math inline">\(dy/dx &gt; 0\)</span>) and on the right, a locally decreasing function (<span class="math inline">\(dy/dx &lt; 0\)</span>). In order to preserve total probability, the change of <span class="math inline">\(p(x)\)</span> along interval <span class="math inline">\(dx\)</span> must be equivalent to the change of <span class="math inline">\(p(y)\)</span> along interval <span class="math inline">\(dy\)</span>:</p>
<p><span class="math display">\[p(x) dx = p(y) dy\]</span></p>
<p>In order to conserve probability, we only care about the amount of change in y and not its direction (it doesn’t matter if <span class="math inline">\(f(x)\)</span> is increasing or decreasing at x, we assume the amount of change in y is the same regardless). Therefore, <span class="math inline">\(p(y) = p(x) | dx/dy |\)</span>. Note that in log-space, this is equivalent to <span class="math inline">\(\log p(y) = \log p(x) + \log | dx/dy |\)</span>. Computing log-densities is more well-scaled for numerical stability reasons.</p>
<p>Now let’s consider the multivariate case, with 2 variables. Again, zooming into an infinitesimally small region of our domain, our initial “segment” of the base distribution is now a square with width dx.</p>
<p>Note that a transformation that merely shifts a rectangular patch <span class="math inline">\((x1,x2, x3,x4)\)</span> does not change the area. We are only interested in the rate of change per unit area of x, so the displacement <span class="math inline">\(dx\)</span> can be thought of as a unit of measure, which is arbitrary. To make the following analysis simple and unit-less, let’s investigate a unit square on the origin, i.e. 4 points <span class="math inline">\((0,0), (1,0), (0,1), (1,1)\)</span>.</p>
<p>Multiplying this by the matrix <span class="math inline">\([[a, b];[c, d]]\)</span> will take points on this square into a parallelogram, as shown on the figure to the right (below). <span class="math inline">\((0,0)\)</span> is sent to <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((1,0)\)</span> is sent to <span class="math inline">\((a,b)\)</span>, <span class="math inline">\((1,0)\)</span> sent to <span class="math inline">\((c,d)\)</span>, <span class="math inline">\((1,1)\)</span> sent to <span class="math inline">\((a+c,b+d)\)</span>.</p>
<p>Thus, a unit square in the domain of <span class="math inline">\(X\)</span> corresponds to a deformed parallelogram in the domain of <span class="math inline">\(Y\)</span>, so the per-unit rate of change in area is the area of the parallelogram, i.e. <span class="math inline">\(ad - bc\)</span>. The area of a parallelogram, <span class="math inline">\(ad - bc\)</span>, is nothing more than the absolute value of the determinant of the linear transformation!</p>
<p>In 3 dimensions, the “change in area of parallelogram” becomes a “change in volume of parallelpiped”, and even higher dimensions, this becomes “change in volume of a n-parallelotope”. But the concept remains the same - determinants are nothing more than the amount (and direction) of volume distortion of a linear transformation, generalized to any number of dimensions.</p>
<p>What if the transformation f is nonlinear? Instead of a single parallelogram that tracks the distortion of any point in space, you can picture many infinitesimally small parallelograms corresponding to the amount of volume distortion for each point in the domain. Mathematically, this locally-linear change in volume is <span class="math inline">\(|\text{det}(J(f^{-1}(x)))|\)</span>, where J(f^-1(x)) is the Jacobian of the function inverse - a higher-dimensional generalization of the quantity dx/dy from before.</p>
<p><span class="math display">\[y = f(x)\]</span> <span class="math display">\[p(y) = p(f^{-1}(y)) \cdot |\text{det} J(f^{-1}(y))| = \log p(f^{-1}(y)) + \log |\text{det}(J(f^{-1}(y)))|\]</span></p>
<p>When I learned about determinants in middle &amp; high school I was very confused at the seemingly arbitrary definition of determinants. We were only taught how to compute a determinant, instead of what a determinant meant: the local, linearized rate of volume change of a transformation.</p>
<p>Transformed Distributions in TensorFlow</p>
<p>TensorFlow has an elegant API for transforming distributions. A TransformedDistribution is specified by a base distribution object that we will transform, and a Bijector object that implements 1) a forward transformation <span class="math inline">\(y = f(x)\)</span>, where <span class="math inline">\(f : \mathbb{R}^d → \mathbb{R}^d\)</span> 2) its inverse transformation <span class="math inline">\(x = f^-1(y)\)</span>, and 3) the inverse log determinant of the Jacobian <span class="math inline">\(\log |\text{det}J (f^-1(y))|\)</span>. For the rest of this post, I will abbreviate this quantity as ILDJ.</p>
<p>Under this abstraction, forward sampling is trivial:</p>
<p>bijector.forward(base_dist.sample())</p>
<p>To evaluate log-density of the transformed distribution:</p>
<p>distribution.log_prob(bijector.inverse(x)) + bijector.inverse_log_det_jacobian(x)</p>
<p>Furthermore, if bijector.forward is a differentiable function, then Y = bijector.forward(x) is a re-parameterizable distribution with respect to samples x = base_distribution.sample(). This means that normalizing flows can be used as a drop-in replacement for variational posteriors in a VAE (as an alternative to a Gaussian).</p>
<p>Some commonly used TensorFlow distributions are actually implemented using these TransformedDistributions.</p>
<p>Source Distribution Bijector.forward Transformed Distribution</p>
<p>Normal exp(x) LogNormal Exp(rate=1) -log(x) Gumbel(0,1) Gumbel(0,1) Softmax(x) Gumbel-Softmax / Concrete</p>
<p>Under standard convention, TransformedDistributions are named as <span class="math inline">\(\text{Bijector}^{-1}\text{BaseDistribution}\)</span> so an ExpBijector applied to a Normal distribution becomes LogNormal. There are some exceptions to this naming scheme - the Gumbel-Softmax distribution is implemented as the RelaxedOneHotCategorical distribution, which applies a SoftmaxCentered bijector to a Gumbel distribution.</p>
<p>Normalizing Flows and Learning Flexible Bijectors</p>
<p>Why stop at 1 bijector? We can chain any number of bijectors together, much like we chain layers together in a neural network [3]. This is construct is known as a “normalizing flow”. Additionally, if a bijector has tunable parameters with respect to bijector.log_prob, then the bijector can actually be learned to transform our base distribution to suit arbitrary densities. Each bijector functions as a learnable “layer”, and you can use an optimizer to learn the parameters of the transformation to suit our data distribution we are trying to model. One algorithm to do this is maximum likelihood estimation, which modifies our model parameters so that our training data points have maximum log-probability under our transformed distribution. We compute and optimize over log probabilities rather than probabilities for numerical stability reasons.</p>
<p>This slide from Shakir Mohamed and Danilo Rezende’s UAW talk (slides) that illustrates this concept:</p>
<p>However, computing the determinant of an arbitrary <span class="math inline">\(N \times N\)</span> Jacobian matrix has runtime complexity <span class="math inline">\(O(N^3)\)</span>, which is very expensive to put in a neural network. There is also the trouble of inverting an arbitrary function approximator. Much of the current research on Normalizing Flows focuses on how to design expressive Bijectors that exploit GPU parallelism during forward and inverse computations, all while maintaining computationally efficient ILDJs.</p>
<p>Code Example</p>
<p>Let’s build a basic normalizing flow in TensorFlow in about 100 lines of code. This code example will make use of:</p>
<p>TF Distributions - general API for manipulating distributions in TF. For this tutorial you’ll need TensorFlow r1.5 or later. TF Bijector - general API for creating operators on distributions Numpy, Matplotlib.</p>
<p>We are trying to model the distribution <span class="math inline">\(p(x_1, x_2) = \mathcal{N}(x1|\mu=1/4x_2^2, \sigma=1) \cdot N(x_2|\mu=0, \sigma=4)\)</span>. We can generate samples from the target distribution using the following code snippet (we generate them in TensorFlow to avoid having to copy samples from the CPU to the GPU on each minibatch):</p>
<p>For our base distribution, we’ll use an Isotropic Gaussian.</p>
<p>Next, we construct the bijector and create a TransformedDistribution from it. Let’s build a flow that resembles a standard fully-connected network, i.e. alternating matrix multiplication with nonlinearities.</p>
<p>The Jacobian of an affine function is trivial to compute, but worst case determinants are <span class="math inline">\(O(n^3)\)</span>, which is unacceptably slow to compute. Instead, TensorFlow provides a structured affine transformation whose determinant can be computed more efficiently. This Affine transform is parameterized as a lower triangular matrix <span class="math inline">\(M\)</span> plus a low rank update:</p>
<p><span class="math display">\[M + V \cdot D \cdot V^T\]</span></p>
<p>To compute <span class="math inline">\(\text{det}(M + V \cdot D \cdot V^T)\)</span> cheaply, we use the matrix determinant lemma.</p>
<p>Next, we need an invertible nonlinearity in order to express non-linear functions (otherwise the chain of affine bijectors remains affine). Sigmoid / tanh may seem like good choices, but they are incredibly unstable to invert - small changes in the output near -1 or 1 correspond to massive changes in input. In my experiments I could not chain 2 saturating nonlinearities together without gradients exploding. Meanwhile, ReLU is stable, but not invertible for <span class="math inline">\(x &lt; 0\)</span>.</p>
<p>I chose to implement PReLU (parameterized ReLU), which is the same as Leaky ReLU but with a learnable slope in the negative regime. The simplicity of PReLU and its straightforward Jacobian makes for a nice exercise in implementing your own custom Bijectors: notice that the ILDJ is 0 when <span class="math inline">\(x &gt; 0\)</span> (no volume change) and <span class="math inline">\(1/\alpha\)</span> otherwise (compensating for the contraction in volume from multiplying x by <span class="math inline">\(\alpha\)</span>).</p>
<p>PReLU is an element-wise transformation, so the Jacobian is diagonal. The determinant of a diagonal matrix is just the product of the diagonal entries, so we compute the ILDJ by simply summing the diagonal entries of the log-Jacobian [4]. We build the “MLP Bijector” by using tfb.Chain(), then apply it to our base distribution to create the transformed distribution:</p>
<p>Finally, we’ll train the model using Maximum Likelihood estimation: maximize the expected log probability of samples from the real data distribution, under our choice of model.</p>
<p>We can visualize the (slow) deformation of space by coloring samples from base distribution according to their starting quadrant,</p>
<p>And that’s it! TensorFlow distributions makes normalizing flows to implement, and automatically accumulate all the Jacobians determinants in a way that is clean and highly readable. Full source code for this post can be found on Github.</p>
<p>You might notice that the deformation is rather slow, and it takes a lot of layers to learn a rather simple transformation [5]. In the next post, I will cover more modern techniques for learning normalizing flows.</p>
<p>Acknowledgements</p>
<p>I am very grateful to Dustin Tran for clarifying my understanding of normalizing flows, Luke Metz, Katherine Lee, and Samy Bengio for proofreading this post, and to Ben Poole, Rif A. Saurous, Ian Langmore for helping me to debug my code. You rock!</p>
<p>Footnotes</p>
<p>[1] The notion that we can augment our dataset with <em>new</em> information from a finite set of data is a rather disturbing one, and it remains to be shown whether probabilistic machine learning can truly replace true generative processes (e.g. simulation of fluid dynamics), or whether at the end of the day it is only good for amortizing computation and any generalization we get on the training / test distribution is a lucky accident. [2] See A note on the evaluation of generative models for a thought-provoking discussion about how high log-likelihood is neither sufficient nor necessary to generate “plausible” images. Still, it’s better than nothing and in practice a useful diagnostic tool. [3]There’s a connection between Normalizing Flows and GANs via encoder-decoder GAN architectures that learn the inverse of the generator (ALI / BiGAN). Since there is a separate encoder trying to recover <span class="math inline">\(u = G^{-1}(X)\)</span> such that <span class="math inline">\(X = G(u)\)</span>, the generator can be thought of as a flow for the simple uniform distribution. However, we don’t know how to compute the amount of volume expansion/contraction w.r.t. X, so we cannot recover density from GANs. However, it’s probably not entirely unreasonable to model the log-det-jacobian numerically or enforce some kind of linear-time Jacobian by construction. [4] The lemma “Determinant of diagonal matrices is the product of the diagonal entries” is quite intuitive from a geometric point of view: each dimension’s length distortion is independent of the other dimensions, so the total volume change is just the product of changes in each direction, as if we were computing the volume of a high-dimensional rectangular prism. [5] This MLP is rather limited in capacity because each affine transformation is only a 2x2 matrix, and the PReLU “warps” the underlying distribution very slowly (so several PreLUs are needed to bend the data into the right shape). For low dimensional distributions, this MLP is a very poor choice of a normalizing flow, and is meant for educational purposes.</p>

      </div>

      


<div class="article-tags">
  
  <a class="btn btn-primary btn-outline" href="../../tags/stats">stats</a>
  
</div>



    </div>
  </div>

</article>



<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3>Related</h3>
  <ul>
    
    <li><a href="../../post/2018-01-12-%E7%9F%A9%E9%98%B5%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">矩阵代数学习笔记</a></li>
    
    <li><a href="../../post/regression/">统计建模中的一切都可以看作是一个回归</a></li>
    
    <li><a href="../../post/2018-01-02-%E5%88%B0%E5%BA%95%E6%98%AF%E5%9B%BA%E5%AE%9A%E8%BF%98%E6%98%AF%E9%9A%8F%E6%9C%BA/">到底是固定还是随机？</a></li>
    
    <li><a href="../../post/a-gentle-inla-tutorial/">INLA教程|A gentle INLA tutorial</a></li>
    
    <li><a href="../../project/stats_r/">统计&amp;编程</a></li>
    
  </ul>
</div>




<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "dong" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2018 Dong &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    
    <script id="dsq-count-scr" src="//dong.disqus.com/count.js" async></script>
    

    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    
    <script src="../../js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

